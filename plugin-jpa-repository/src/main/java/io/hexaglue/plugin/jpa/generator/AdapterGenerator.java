/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.CodeBlock;
import com.palantir.javapoet.FieldSpec;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterSpec;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.model.IdModel;
import io.hexaglue.plugin.jpa.model.JpaGenerationPlan;
import io.hexaglue.plugin.jpa.model.QueryMethodModel;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.MergeMode;
import io.hexaglue.spi.codegen.SourceFile;
import io.hexaglue.spi.context.GenerationContextSpec;
import io.hexaglue.spi.ir.domain.DomainTypeKind;
import io.hexaglue.spi.ir.domain.DomainTypeView;
import io.hexaglue.spi.ir.ports.PortMethodView;
import io.hexaglue.spi.ir.ports.PortParameterView;
import io.hexaglue.spi.types.TypeRef;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;
import javax.lang.model.element.Modifier;

/**
 * Generates adapter implementations for repository ports.
 *
 * <p>This generator creates adapter classes that:</p>
 * <ul>
 *   <li><strong>Implement the port interface</strong></li>
 *   <li><strong>Delegate to Spring Data repository</strong></li>
 *   <li><strong>Use MapStruct mapper</strong> for domain ↔ entity conversion</li>
 *   <li><strong>Handle common patterns</strong>: save, findById, delete, exists, count, queries</li>
 * </ul>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Component
 * public final class CustomerAdapter implements CustomerRepository {
 *
 *     private final CustomerJpaRepository repo;
 *     private final CustomerMapper mapper;
 *
 *     public CustomerAdapter(CustomerJpaRepository repo, CustomerMapper mapper) {
 *         this.repo = Objects.requireNonNull(repo, "repo");
 *         this.mapper = Objects.requireNonNull(mapper, "mapper");
 *     }
 *
 *     @Override
 *     public Customer save(Customer customer) {
 *         CustomerEntity entity = mapper.toEntity(customer);
 *         CustomerEntity saved = repo.save(entity);
 *         return mapper.toDomain(saved);
 *     }
 *
 *     @Override
 *     public Optional<Customer> findById(CustomerId id) {
 *         return repo.findById(id.value()).map(mapper::toDomain);
 *     }
 *
 *     // ... more methods
 * }
 * }</pre>
 *
 * @since 0.4.0
 */
public final class AdapterGenerator {

    private final GenerationContextSpec context;

    public AdapterGenerator(GenerationContextSpec context) {
        this.context = Objects.requireNonNull(context, "context");
    }

    /**
     * Generates an adapter source file.
     *
     * @param plan generation plan containing port and entity metadata
     * @param mergeMode merge mode for file generation
     * @return source file containing the adapter implementation
     */
    public SourceFile generate(JpaGenerationPlan plan, MergeMode mergeMode) {
        Objects.requireNonNull(plan, "plan");
        Objects.requireNonNull(mergeMode, "mergeMode");

        String qualifiedName = plan.adapterQualifiedName();
        String packageName = extractPackage(qualifiedName);
        String simpleName = extractSimpleName(qualifiedName);

        TypeName portType = ClassName.bestGuess(plan.portQualifiedName());
        TypeName repoType = ClassName.bestGuess(plan.springDataRepoQualifiedName());
        TypeName mapperType = ClassName.bestGuess(plan.mapperQualifiedName());

        TypeSpec.Builder adapterBuilder = TypeSpec.classBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addJavadoc("Spring Data JPA adapter implementing $L.\n", plan.portQualifiedName())
                .addJavadoc("\n<p>Generated by HexaGlue JPA plugin.</p>\n")
                .addAnnotation(ClassName.get("org.springframework.stereotype", "Component"))
                .addSuperinterface(portType);

        // Fields
        adapterBuilder.addField(FieldSpec.builder(repoType, "repo", Modifier.PRIVATE, Modifier.FINAL)
                .build());
        adapterBuilder.addField(FieldSpec.builder(mapperType, "mapper", Modifier.PRIVATE, Modifier.FINAL)
                .build());

        // Constructor
        adapterBuilder.addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameter(repoType, "repo")
                .addParameter(mapperType, "mapper")
                .addStatement("this.repo = $T.requireNonNull(repo, $S)", Objects.class, "repo")
                .addStatement("this.mapper = $T.requireNonNull(mapper, $S)", Objects.class, "mapper")
                .build());

        // Implement port methods
        for (PortMethodView method : plan.port().methods()) {
            if (method.isDefault() || method.isStatic()) {
                continue;
            }

            adapterBuilder.addMethod(generateMethodImplementation(method, plan));
        }

        JavaFile javaFile =
                JavaFile.builder(packageName, adapterBuilder.build()).build();

        return SourceFile.builder()
                .qualifiedTypeName(qualifiedName)
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }

    /**
     * Generates implementation for a port method.
     */
    private MethodSpec generateMethodImplementation(PortMethodView method, JpaGenerationPlan plan) {
        MethodSpec.Builder builder = MethodSpec.methodBuilder(method.name())
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override.class)
                .returns(TypeUtils.toTypeName(method.returnType()));

        // Add parameters
        for (PortParameterView param : method.parameters()) {
            TypeName paramType = TypeUtils.toTypeName(param.type());
            if (param.isVarArgs()) {
                builder.addParameter(
                        ParameterSpec.builder(paramType, param.name()).build());
                builder.varargs(true);
            } else {
                builder.addParameter(paramType, param.name());
            }
        }

        // Generate implementation
        CodeBlock implementation = generateImplementation(method, plan);
        builder.addCode(implementation);

        return builder.build();
    }

    /**
     * Generates method implementation based on pattern matching.
     */
    private CodeBlock generateImplementation(PortMethodView method, JpaGenerationPlan plan) {
        String methodName = method.name().toLowerCase(Locale.ROOT);
        List<PortParameterView> params = method.parameters();

        // Check if this is a derived query method
        Optional<QueryMethodModel> queryMethod = findQueryMethod(method.name(), plan);
        if (queryMethod.isPresent()) {
            return generateQueryMethodImplementation(queryMethod.get(), method);
        }

        // Pattern: save(Domain) -> Domain
        if (methodName.equals("save") && params.size() == 1) {
            return generateSaveImplementation(params.get(0).name());
        }

        // Pattern: findById(ID) -> Optional<Domain>
        if (methodName.equals("findbyid") && params.size() == 1) {
            return generateFindByIdImplementation(
                    params.get(0), plan.entityModel().idModel());
        }

        // Pattern: existsById(ID) -> boolean
        if (methodName.equals("existsbyid") && params.size() == 1) {
            return generateExistsByIdImplementation(
                    params.get(0), plan.entityModel().idModel());
        }

        // Pattern: deleteById(ID) -> void or boolean
        if (methodName.equals("deletebyid") && params.size() == 1) {
            boolean returnsBoolean = !method.returnType().render().equals("void");
            return generateDeleteByIdImplementation(params.get(0), plan, returnsBoolean);
        }

        // Pattern: count() -> long
        if (methodName.equals("count") && params.isEmpty()) {
            return CodeBlock.builder().addStatement("return repo.count()").build();
        }

        // Fallback: stub
        return generateStubImplementation(method);
    }

    /**
     * Finds a QueryMethodModel for the given method name.
     */
    private Optional<QueryMethodModel> findQueryMethod(String methodName, JpaGenerationPlan plan) {
        return plan.queryMethods().stream()
                .filter(qm -> qm.methodName().equals(methodName))
                .findFirst();
    }

    private CodeBlock generateSaveImplementation(String paramName) {
        return CodeBlock.builder()
                .addStatement("var entity = mapper.toEntity($L)", paramName)
                .addStatement("var saved = repo.save(entity)")
                .addStatement("return mapper.toDomain(saved)")
                .build();
    }

    private CodeBlock generateFindByIdImplementation(PortParameterView param, IdModel idModel) {
        String paramName = param.name();
        String idExpression = getIdUnwrapExpression(param.type(), paramName, idModel);

        return CodeBlock.builder()
                .addStatement("return repo.findById($L).map(mapper::toDomain)", idExpression)
                .build();
    }

    private CodeBlock generateExistsByIdImplementation(PortParameterView param, IdModel idModel) {
        String paramName = param.name();
        String idExpression = getIdUnwrapExpression(param.type(), paramName, idModel);

        return CodeBlock.builder()
                .addStatement("return repo.existsById($L)", idExpression)
                .build();
    }

    private CodeBlock generateDeleteByIdImplementation(
            PortParameterView param, JpaGenerationPlan plan, boolean returnsBoolean) {
        String paramName = param.name();
        IdModel idModel = plan.entityModel().idModel();
        String idExpression = getIdUnwrapExpression(param.type(), paramName, idModel);
        boolean enableSoftDelete = plan.entityModel().enableSoftDelete();

        // Soft delete: load entity, set deletedAt, save
        if (enableSoftDelete) {
            if (returnsBoolean) {
                return CodeBlock.builder()
                        .addStatement(
                                "return repo.findById($L).map(entity -> { entity.setDeletedAt($T.now()); repo.save(entity); return true; }).orElse(false)",
                                idExpression,
                                ClassName.get("java.time", "Instant"))
                        .build();
            } else {
                return CodeBlock.builder()
                        .addStatement("var entity = repo.findById($L).orElse(null)", idExpression)
                        .beginControlFlow("if (entity != null)")
                        .addStatement("entity.setDeletedAt($T.now())", ClassName.get("java.time", "Instant"))
                        .addStatement("repo.save(entity)")
                        .endControlFlow()
                        .build();
            }
        }

        // Hard delete: use repository deleteById
        if (returnsBoolean) {
            return CodeBlock.builder()
                    .beginControlFlow("if (!repo.existsById($L))", idExpression)
                    .addStatement("return false")
                    .endControlFlow()
                    .addStatement("repo.deleteById($L)", idExpression)
                    .addStatement("return true")
                    .build();
        } else {
            return CodeBlock.builder()
                    .addStatement("repo.deleteById($L)", idExpression)
                    .build();
        }
    }

    /**
     * Generates implementation for a derived query method.
     *
     * <p>Handles all query types:</p>
     * <ul>
     *   <li>EXISTS_BY → delegate to repo, return boolean</li>
     *   <li>COUNT_BY → delegate to repo, return long</li>
     *   <li>DELETE_BY → delegate to repo, return void</li>
     *   <li>FIND_BY → delegate + map results (Optional, List, Page, or single)</li>
     * </ul>
     */
    private CodeBlock generateQueryMethodImplementation(QueryMethodModel queryMethod, PortMethodView method) {
        String paramList = buildParamList(method.parameters());
        String methodName = queryMethod.methodName();

        switch (queryMethod.queryType()) {
            case EXISTS_BY:
                // Delegate to repository - returns boolean directly
                return CodeBlock.builder()
                        .addStatement("return repo.$L($L)", methodName, paramList)
                        .build();

            case COUNT_BY:
                // Delegate to repository - returns long directly
                return CodeBlock.builder()
                        .addStatement("return repo.$L($L)", methodName, paramList)
                        .build();

            case DELETE_BY:
                // Delegate to repository - returns void
                return CodeBlock.builder()
                        .addStatement("repo.$L($L)", methodName, paramList)
                        .build();

            case FIND_BY:
            case FIND_ALL:
                return generateFindByImplementation(queryMethod, methodName, paramList);

            default:
                return generateStubImplementation(method);
        }
    }

    /**
     * Generates implementation for findBy query methods.
     */
    private CodeBlock generateFindByImplementation(QueryMethodModel queryMethod, String methodName, String paramList) {

        if (queryMethod.returnsOptional()) {
            // Optional<Domain> - map single result
            return CodeBlock.builder()
                    .addStatement("return repo.$L($L).map(mapper::toDomain)", methodName, paramList)
                    .build();
        } else if (queryMethod.returnsPage()) {
            // Page<Domain> - map page content
            return CodeBlock.builder()
                    .addStatement("return repo.$L($L).map(mapper::toDomain)", methodName, paramList)
                    .build();
        } else if (queryMethod.returnsList()) {
            // List<Domain> - stream and map
            return CodeBlock.builder()
                    .addStatement("return repo.$L($L).stream().map(mapper::toDomain).toList()", methodName, paramList)
                    .build();
        } else {
            // Single entity - need to handle null
            return CodeBlock.builder()
                    .addStatement("var entity = repo.$L($L)", methodName, paramList)
                    .addStatement("return entity != null ? mapper.toDomain(entity) : null")
                    .build();
        }
    }

    private CodeBlock generateStubImplementation(PortMethodView method) {
        if (method.returnType().render().equals("void")) {
            return CodeBlock.builder()
                    .add("// TODO: Implement " + method.name() + "\n")
                    .build();
        } else {
            return CodeBlock.builder()
                    .add("// TODO: Implement " + method.name() + "\n")
                    .addStatement(
                            "throw new $T($S)",
                            UnsupportedOperationException.class,
                            "Method " + method.name() + " not implemented")
                    .build();
        }
    }

    /**
     * Gets ID unwrap expression (e.g., "id.value()" for Value Object IDs).
     */
    private String getIdUnwrapExpression(TypeRef idType, String paramName, IdModel idModel) {
        if (!idModel.isUnwrapped()) {
            return paramName;
        }

        // Look up ID type in domain model
        Optional<DomainTypeView> domainType = context.model().domain().findType(idType.render());

        if (domainType.isPresent()) {
            DomainTypeView type = domainType.get();
            if ((type.kind() == DomainTypeKind.IDENTIFIER || type.kind() == DomainTypeKind.RECORD)
                    && type.properties().size() == 1) {
                String propertyName = type.properties().get(0).name();
                return paramName + "." + propertyName + "()";
            }
        }

        return paramName;
    }

    private String buildParamList(List<PortParameterView> params) {
        if (params.isEmpty()) {
            return "";
        }
        return params.stream()
                .map(PortParameterView::name)
                .reduce((a, b) -> a + ", " + b)
                .orElse("");
    }

    private String extractPackage(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? "" : qualifiedName.substring(0, lastDot);
    }

    private String extractSimpleName(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? qualifiedName : qualifiedName.substring(lastDot + 1);
    }
}

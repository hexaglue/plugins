/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.AnnotationSpec;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.MergeMode;
import io.hexaglue.spi.codegen.SourceFile;
import io.hexaglue.spi.ir.domain.DomainPropertyView;
import io.hexaglue.spi.ir.domain.DomainTypeView;
import java.util.Objects;
import javax.lang.model.element.Modifier;

/**
 * Generates JPA AttributeConverter classes for single-field Value Objects.
 *
 * <p>This generator creates converter classes for scalar Value Objects that wrap
 * a single primitive or simple type. The converters handle bidirectional conversion
 * between domain Value Objects and database column types.</p>
 *
 * <h2>Use Cases</h2>
 * <ul>
 *   <li><strong>Type-safe IDs</strong>: CustomerId, OrderId (wrapping UUID/String)</li>
 *   <li><strong>Simple VOs</strong>: Email, PhoneNumber (wrapping String)</li>
 *   <li><strong>Quantities</strong>: Quantity, Amount (wrapping int/long)</li>
 * </ul>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Converter(autoApply = false)
 * public class CustomerIdConverter implements AttributeConverter<CustomerId, UUID> {
 *
 *     @Override
 *     public UUID convertToDatabaseColumn(CustomerId attribute) {
 *         return attribute == null ? null : attribute.value();
 *     }
 *
 *     @Override
 *     public CustomerId convertToEntityAttribute(UUID dbData) {
 *         return dbData == null ? null : new CustomerId(dbData);
 *     }
 * }
 * }</pre>
 *
 * <h2>Integration</h2>
 * <p>Converters are applied using @Convert annotation on entity fields:</p>
 * <pre>{@code
 * @Convert(converter = CustomerIdConverter.class)
 * private UUID customerId;
 * }</pre>
 *
 * @since 0.4.0
 */
public final class ConverterGenerator {

    private final String basePackage;

    public ConverterGenerator(String basePackage) {
        this.basePackage = Objects.requireNonNull(basePackage, "basePackage");
    }

    /**
     * Generates a JPA AttributeConverter for a single-field Value Object.
     *
     * @param valueObjectType domain Value Object type view (must have exactly 1 property)
     * @param mergeMode merge mode for file generation
     * @return source file containing the converter class
     * @throws IllegalArgumentException if VO doesn't have exactly 1 property
     */
    public SourceFile generate(DomainTypeView valueObjectType, MergeMode mergeMode) {
        Objects.requireNonNull(valueObjectType, "valueObjectType");
        Objects.requireNonNull(mergeMode, "mergeMode");

        if (valueObjectType.properties().size() != 1) {
            throw new IllegalArgumentException("ConverterGenerator only supports single-field Value Objects. "
                    + valueObjectType.qualifiedName() + " has "
                    + valueObjectType.properties().size() + " properties.");
        }

        DomainPropertyView innerProperty = valueObjectType.properties().get(0);
        String simpleName = valueObjectType.simpleName() + "Converter";
        String packageName = basePackage + ".converter";
        String qualifiedName = packageName + "." + simpleName;

        TypeName voTypeName = ClassName.bestGuess(valueObjectType.qualifiedName());
        TypeName dbTypeName = TypeUtils.toTypeName(innerProperty.type());

        // Build converter class implementing AttributeConverter<VO, DB>
        ClassName attributeConverterClass = ClassName.get("jakarta.persistence", "AttributeConverter");
        TypeName converterInterface = ParameterizedTypeName.get(attributeConverterClass, voTypeName, dbTypeName);

        TypeSpec.Builder converterBuilder = TypeSpec.classBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(converterInterface)
                .addJavadoc("JPA AttributeConverter for $L ↔ $L.\\n", voTypeName, dbTypeName)
                .addJavadoc("\\n<p>Generated by HexaGlue JPA plugin.</p>\\n");

        // Add @Converter annotation (autoApply = false by default)
        converterBuilder.addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Converter"))
                .addMember("autoApply", "$L", false)
                .build());

        // convertToDatabaseColumn method (VO → DB)
        converterBuilder.addMethod(MethodSpec.methodBuilder("convertToDatabaseColumn")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(dbTypeName)
                .addParameter(voTypeName, "attribute")
                .addStatement("return attribute == null ? null : attribute.$L()", innerProperty.name())
                .addJavadoc("Converts Value Object to database column type.\\n")
                .addJavadoc("\\n@param attribute Value Object\\n")
                .addJavadoc("@return database column value\\n")
                .build());

        // convertToEntityAttribute method (DB → VO)
        converterBuilder.addMethod(MethodSpec.methodBuilder("convertToEntityAttribute")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(voTypeName)
                .addParameter(dbTypeName, "dbData")
                .addStatement("return dbData == null ? null : new $T(dbData)", voTypeName)
                .addJavadoc("Converts database column to Value Object.\\n")
                .addJavadoc("\\n@param dbData database column value\\n")
                .addJavadoc("@return Value Object\\n")
                .build());

        JavaFile javaFile =
                JavaFile.builder(packageName, converterBuilder.build()).build();

        return SourceFile.builder()
                .qualifiedTypeName(qualifiedName)
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }
}

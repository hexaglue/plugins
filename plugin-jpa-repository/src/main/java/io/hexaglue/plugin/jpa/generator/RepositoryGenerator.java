/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.ParameterizedTypeName;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.model.JpaGenerationPlan;
import io.hexaglue.plugin.jpa.model.QueryMethodModel;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.MergeMode;
import io.hexaglue.spi.codegen.SourceFile;
import java.util.Objects;
import javax.lang.model.element.Modifier;

/**
 * Generates Spring Data JPA repository interfaces.
 *
 * <p>This generator creates repository interfaces that extend
 * {@code JpaRepository<Entity, ID>} and adds derived query methods
 * based on the port's method signatures.</p>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Repository
 * public interface CustomerJpaRepository extends JpaRepository<CustomerEntity, String> {
 *
 *     Optional<CustomerEntity> findByEmail(String email);
 *
 *     List<CustomerEntity> findAllByStatus(CustomerStatus status);
 *
 *     boolean existsByEmail(String email);
 * }
 * }</pre>
 *
 * <h2>Derived Query Methods</h2>
 * <p>Spring Data automatically implements query methods based on naming conventions:</p>
 * <ul>
 *   <li>{@code findByEmail(String)} → SELECT ... WHERE email = ?</li>
 *   <li>{@code findAllByStatus(Status)} → SELECT ... WHERE status = ?</li>
 *   <li>{@code existsByEmail(String)} → SELECT COUNT ... WHERE email = ?</li>
 * </ul>
 *
 * @since 0.4.0
 */
public final class RepositoryGenerator {

    private final boolean generateQueryMethods;

    public RepositoryGenerator(boolean generateQueryMethods) {
        this.generateQueryMethods = generateQueryMethods;
    }

    /**
     * Generates a Spring Data repository source file.
     *
     * @param plan generation plan containing entity and port metadata
     * @param mergeMode merge mode for file generation
     * @return source file containing the repository interface
     */
    public SourceFile generate(JpaGenerationPlan plan, MergeMode mergeMode) {
        Objects.requireNonNull(plan, "plan");
        Objects.requireNonNull(mergeMode, "mergeMode");

        String qualifiedName = plan.springDataRepoQualifiedName();
        String packageName = extractPackage(qualifiedName);
        String simpleName = extractSimpleName(qualifiedName);

        TypeName entityType = ClassName.bestGuess(plan.entityQualifiedName());
        TypeName idType = TypeUtils.toTypeName(plan.entityModel().idModel().unwrappedType());

        // JpaRepository<Entity, ID>
        ClassName jpaRepositoryClass = ClassName.get("org.springframework.data.jpa.repository", "JpaRepository");
        TypeName superInterface = ParameterizedTypeName.get(jpaRepositoryClass, entityType, idType);

        TypeSpec.Builder repoBuilder = TypeSpec.interfaceBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc(
                        "Spring Data JPA repository for $L.\n",
                        plan.entityModel().domainType().render())
                .addJavadoc("\n<p>Generated by HexaGlue JPA plugin.</p>\n")
                .addSuperinterface(superInterface);

        // Add @Repository annotation (optional but recommended)
        repoBuilder.addAnnotation(ClassName.get("org.springframework.stereotype", "Repository"));

        // Generate derived query methods if enabled
        if (generateQueryMethods) {
            addDerivedQueryMethods(repoBuilder, plan);
        }

        JavaFile javaFile = JavaFile.builder(packageName, repoBuilder.build()).build();

        return SourceFile.builder()
                .qualifiedTypeName(qualifiedName)
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }

    /**
     * Adds derived query methods from the generation plan.
     *
     * <p>This method uses the pre-analyzed QueryMethodModel instances
     * to generate Spring Data repository query methods.</p>
     */
    private void addDerivedQueryMethods(TypeSpec.Builder repoBuilder, JpaGenerationPlan plan) {
        for (QueryMethodModel queryMethod : plan.queryMethods()) {
            addQueryMethod(repoBuilder, queryMethod, plan);
        }
    }

    /**
     * Adds a single derived query method from QueryMethodModel.
     */
    private void addQueryMethod(TypeSpec.Builder repoBuilder, QueryMethodModel queryMethod, JpaGenerationPlan plan) {
        MethodSpec.Builder methodBuilder =
                MethodSpec.methodBuilder(queryMethod.methodName()).addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);

        // Return type: convert based on query type
        TypeName returnType = buildReturnType(queryMethod, plan);
        methodBuilder.returns(returnType);

        // Parameters
        for (var param : queryMethod.parameters()) {
            TypeName paramType = TypeUtils.toTypeName(param.type());
            methodBuilder.addParameter(paramType, param.name());
        }

        // Add Javadoc
        methodBuilder.addJavadoc("Derived query method: $L.\n", queryMethod.queryType());
        if (!queryMethod.queryPredicate().isEmpty()) {
            methodBuilder.addJavadoc("\n<p>Query predicate: $L</p>\n", queryMethod.queryPredicate());
        }
        methodBuilder.addJavadoc("\n<p>Spring Data automatically implements this based on method name.</p>\n");

        repoBuilder.addMethod(methodBuilder.build());
    }

    /**
     * Builds the return type for a query method.
     *
     * <p>Handles:</p>
     * <ul>
     *   <li>EXISTS_BY → boolean</li>
     *   <li>COUNT_BY → long</li>
     *   <li>DELETE_BY → void</li>
     *   <li>FIND_BY with Optional → Optional&lt;Entity&gt;</li>
     *   <li>FIND_BY with List → List&lt;Entity&gt;</li>
     *   <li>FIND_BY with Page → Page&lt;Entity&gt;</li>
     *   <li>FIND_BY single → Entity</li>
     * </ul>
     */
    private TypeName buildReturnType(QueryMethodModel queryMethod, JpaGenerationPlan plan) {
        TypeName entityType = ClassName.bestGuess(plan.entityQualifiedName());

        switch (queryMethod.queryType()) {
            case EXISTS_BY:
                return TypeName.BOOLEAN;

            case COUNT_BY:
                return TypeName.LONG;

            case DELETE_BY:
                return TypeName.VOID;

            case FIND_BY:
            case FIND_ALL:
                if (queryMethod.returnsOptional()) {
                    return ParameterizedTypeName.get(ClassName.get("java.util", "Optional"), entityType);
                } else if (queryMethod.returnsPage()) {
                    return ParameterizedTypeName.get(
                            ClassName.get("org.springframework.data.domain", "Page"), entityType);
                } else if (queryMethod.returnsList()) {
                    return ParameterizedTypeName.get(ClassName.get("java.util", "List"), entityType);
                } else {
                    return entityType;
                }

            default:
                return TypeUtils.toTypeName(queryMethod.returnType());
        }
    }

    private String extractPackage(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? "" : qualifiedName.substring(0, lastDot);
    }

    private String extractSimpleName(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? qualifiedName : qualifiedName.substring(lastDot + 1);
    }
}

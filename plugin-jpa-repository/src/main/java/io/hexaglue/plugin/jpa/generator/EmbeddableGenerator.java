/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.AnnotationSpec;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.FieldSpec;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.MergeMode;
import io.hexaglue.spi.codegen.SourceFile;
import io.hexaglue.spi.ir.domain.DomainPropertyView;
import io.hexaglue.spi.ir.domain.DomainTypeView;
import java.util.Objects;
import javax.lang.model.element.Modifier;

/**
 * Generates JPA @Embeddable classes for multi-field Value Objects.
 *
 * <p>This generator creates @Embeddable classes that can be embedded in JPA entities
 * using @Embedded. The embeddables handle:</p>
 * <ul>
 *   <li><strong>Multi-field Value Objects</strong>: Address, Money, etc.</li>
 *   <li><strong>Column mappings</strong>: @Column annotations for each field</li>
 *   <li><strong>Accessors</strong>: Getters and setters for JPA</li>
 *   <li><strong>No-arg constructor</strong>: Required by JPA</li>
 * </ul>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Embeddable
 * public class AddressEmbeddable {
 *
 *     @Column(name = "street")
 *     private String street;
 *
 *     @Column(name = "city")
 *     private String city;
 *
 *     @Column(name = "postal_code")
 *     private String postalCode;
 *
 *     @Column(name = "country")
 *     private String country;
 *
 *     public AddressEmbeddable() {}
 *
 *     // Getters and setters...
 * }
 * }</pre>
 *
 * @since 0.4.0
 */
public final class EmbeddableGenerator {

    private final String basePackage;

    public EmbeddableGenerator(String basePackage) {
        this.basePackage = Objects.requireNonNull(basePackage, "basePackage");
    }

    /**
     * Generates a JPA @Embeddable source file from a domain Value Object type.
     *
     * <p>For composite IDs, the embeddable class will also:</p>
     * <ul>
     *   <li>Implement {@link java.io.Serializable}</li>
     *   <li>Include equals/hashCode based on all fields</li>
     * </ul>
     *
     * @param valueObjectType domain Value Object type view
     * @param mergeMode merge mode for file generation
     * @return source file containing the generated embeddable class
     */
    public SourceFile generate(DomainTypeView valueObjectType, MergeMode mergeMode) {
        return generate(valueObjectType, mergeMode, false);
    }

    /**
     * Generates a JPA @Embeddable source file from a domain Value Object type.
     *
     * @param valueObjectType domain Value Object type view
     * @param mergeMode merge mode for file generation
     * @param isCompositeId true if this embeddable is used as a composite ID
     * @return source file containing the generated embeddable class
     */
    public SourceFile generate(DomainTypeView valueObjectType, MergeMode mergeMode, boolean isCompositeId) {
        Objects.requireNonNull(valueObjectType, "valueObjectType");
        Objects.requireNonNull(mergeMode, "mergeMode");

        String simpleName = valueObjectType.simpleName() + "Embeddable";
        String packageName = basePackage + ".embeddable";
        String qualifiedName = packageName + "." + simpleName;

        // Build embeddable class
        TypeSpec.Builder embeddableBuilder = TypeSpec.classBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("JPA embeddable for $L.\\n", valueObjectType.qualifiedName())
                .addJavadoc("\\n<p>Generated by HexaGlue JPA plugin.</p>\\n");

        // Composite IDs must implement Serializable
        if (isCompositeId) {
            embeddableBuilder.addSuperinterface(ClassName.get("java.io", "Serializable"));
            embeddableBuilder.addJavadoc("\\n<p>Implements Serializable as required for composite IDs.</p>\\n");
        }

        // Add @Embeddable annotation
        embeddableBuilder.addAnnotation(ClassName.get("jakarta.persistence", "Embeddable"));

        // Add fields for each property
        for (DomainPropertyView property : valueObjectType.properties()) {
            addPropertyField(embeddableBuilder, property);
        }

        // Add no-arg constructor (required by JPA)
        embeddableBuilder.addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("No-arg constructor required by JPA.\\n")
                .build());

        // Add getters and setters
        for (DomainPropertyView property : valueObjectType.properties()) {
            addPropertyAccessors(embeddableBuilder, property);
        }

        // Add equals/hashCode for composite IDs
        if (isCompositeId) {
            addEqualsAndHashCode(embeddableBuilder, valueObjectType);
        }

        // Build Java file
        JavaFile javaFile =
                JavaFile.builder(packageName, embeddableBuilder.build()).build();

        return SourceFile.builder()
                .qualifiedTypeName(qualifiedName)
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }

    /**
     * Adds a property field with @Column annotation.
     */
    private void addPropertyField(TypeSpec.Builder embeddableBuilder, DomainPropertyView property) {
        TypeName propertyType = TypeUtils.toTypeName(property.type());
        String columnName = toSnakeCase(property.name());

        FieldSpec.Builder fieldBuilder = FieldSpec.builder(propertyType, property.name(), Modifier.PRIVATE);

        // Add @Column annotation
        AnnotationSpec.Builder columnBuilder = AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                .addMember("name", "$S", columnName);

        fieldBuilder.addAnnotation(columnBuilder.build());
        embeddableBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds getter and setter for a property.
     */
    private void addPropertyAccessors(TypeSpec.Builder embeddableBuilder, DomainPropertyView property) {
        TypeName propertyType = TypeUtils.toTypeName(property.type());
        String capitalizedName = capitalize(property.name());

        // Getter
        embeddableBuilder.addMethod(MethodSpec.methodBuilder("get" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .returns(propertyType)
                .addStatement("return $L", property.name())
                .build());

        // Setter
        embeddableBuilder.addMethod(MethodSpec.methodBuilder("set" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(propertyType, property.name())
                .addStatement("this.$L = $L", property.name(), property.name())
                .build());
    }

    /**
     * Converts camelCase to snake_case.
     */
    private String toSnakeCase(String camelCase) {
        if (camelCase == null || camelCase.isEmpty()) {
            return camelCase;
        }
        return camelCase.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }

    /**
     * Adds equals and hashCode methods for composite IDs.
     *
     * <p>Composite IDs require proper equals/hashCode implementation
     * based on all properties for JPA identity management.</p>
     */
    private void addEqualsAndHashCode(TypeSpec.Builder embeddableBuilder, DomainTypeView valueObjectType) {
        String className = valueObjectType.simpleName() + "Embeddable";

        // Build equals method
        MethodSpec.Builder equalsBuilder = MethodSpec.methodBuilder("equals")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.BOOLEAN)
                .addParameter(ClassName.get("java.lang", "Object"), "o")
                .addStatement("if (this == o) return true")
                .addStatement("if (o == null || getClass() != o.getClass()) return false")
                .addStatement("$L that = ($L) o", className, className);

        // Build comparison expression for all properties
        var properties = valueObjectType.properties();
        if (properties.size() == 1) {
            String prop = properties.get(0).name();
            equalsBuilder.addStatement(
                    "return $T.equals($L, that.$L)", ClassName.get("java.util", "Objects"), prop, prop);
        } else {
            StringBuilder comparison = new StringBuilder("return ");
            for (int i = 0; i < properties.size(); i++) {
                if (i > 0) {
                    comparison.append(" && ");
                }
                String prop = properties.get(i).name();
                comparison
                        .append("$T.equals(")
                        .append(prop)
                        .append(", that.")
                        .append(prop)
                        .append(")");
            }
            equalsBuilder.addStatement(comparison.toString(), ClassName.get("java.util", "Objects"));
        }

        embeddableBuilder.addMethod(equalsBuilder.build());

        // Build hashCode method
        MethodSpec.Builder hashCodeBuilder = MethodSpec.methodBuilder("hashCode")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(TypeName.INT);

        // Build hash expression with all properties
        String hashParams = properties.stream()
                .map(DomainPropertyView::name)
                .reduce((a, b) -> a + ", " + b)
                .orElse("");

        hashCodeBuilder.addStatement("return $T.hash($L)", ClassName.get("java.util", "Objects"), hashParams);

        embeddableBuilder.addMethod(hashCodeBuilder.build());
    }

    /**
     * Capitalizes the first letter of a string.
     */
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
}

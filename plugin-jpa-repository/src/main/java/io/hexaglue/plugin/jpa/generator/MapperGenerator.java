/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.AnnotationSpec;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.model.JpaGenerationPlan;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.MergeMode;
import io.hexaglue.spi.codegen.SourceFile;
import io.hexaglue.spi.context.GenerationContextSpec;
import io.hexaglue.spi.ir.domain.DomainPropertyView;
import io.hexaglue.spi.ir.domain.DomainTypeKind;
import io.hexaglue.spi.ir.domain.DomainTypeView;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.lang.model.element.Modifier;

/**
 * Generates MapStruct mapper interfaces for domain ↔ entity conversion.
 *
 * <p>This generator creates mapper interfaces that MapStruct will implement
 * automatically. The mappers handle:</p>
 * <ul>
 *   <li><strong>Domain to Entity</strong>: toEntity(Domain) → Entity</li>
 *   <li><strong>Entity to Domain</strong>: toDomain(Entity) → Domain</li>
 *   <li><strong>Value Object conversion</strong>: Custom mappers for IDs and embedded VOs</li>
 * </ul>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Mapper(componentModel = "spring")
 * public interface CustomerMapper {
 *
 *     CustomerEntity toEntity(Customer domain);
 *
 *     Customer toDomain(CustomerEntity entity);
 *
 *     // Value Object converter for CustomerId
 *     default String map(CustomerId id) {
 *         return id == null ? null : id.value();
 *     }
 *
 *     default CustomerId map(String value) {
 *         return value == null ? null : new CustomerId(value);
 *     }
 * }
 * }</pre>
 *
 * <h2>MapStruct Benefits</h2>
 * <ul>
 *   <li>Compile-time code generation (type-safe)</li>
 *   <li>Automatic property mapping by name</li>
 *   <li>Support for custom converters</li>
 *   <li>Spring integration via componentModel</li>
 * </ul>
 *
 * @since 0.4.0
 */
public final class MapperGenerator {

    private final GenerationContextSpec context;

    public MapperGenerator(GenerationContextSpec context) {
        this.context = Objects.requireNonNull(context, "context");
    }

    /**
     * Generates a MapStruct mapper source file.
     *
     * @param plan generation plan containing entity and domain metadata
     * @param mergeMode merge mode for file generation
     * @return source file containing the mapper interface
     */
    public SourceFile generate(JpaGenerationPlan plan, MergeMode mergeMode) {
        Objects.requireNonNull(plan, "plan");
        Objects.requireNonNull(mergeMode, "mergeMode");

        String qualifiedName = plan.mapperQualifiedName();
        String packageName = extractPackage(qualifiedName);
        String simpleName = extractSimpleName(qualifiedName);

        TypeName domainType = TypeUtils.toTypeName(plan.entityModel().domainType());
        TypeName entityType = ClassName.bestGuess(plan.entityQualifiedName());

        // MapStruct annotation
        AnnotationSpec mapStructAnnotation = AnnotationSpec.builder(ClassName.get("org.mapstruct", "Mapper"))
                .addMember("componentModel", "$S", "spring")
                .build();

        TypeSpec.Builder mapperBuilder = TypeSpec.interfaceBuilder(simpleName)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("MapStruct mapper for $L ↔ $L conversion.\n", domainType, entityType)
                .addJavadoc("\n<p>Generated by HexaGlue JPA plugin.</p>\n")
                .addJavadoc("<p>MapStruct will generate the implementation automatically.</p>\n")
                .addAnnotation(mapStructAnnotation);

        // Add Value Object converters (e.g., CustomerId ↔ String)
        addValueObjectConverters(mapperBuilder, plan);

        // toEntity method - ignore JPA technical fields (they'll be managed by JPA)
        MethodSpec.Builder toEntityBuilder = MethodSpec.methodBuilder("toEntity")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(entityType)
                .addParameter(domainType, "domain")
                .addJavadoc("Converts domain object to JPA entity.\n")
                .addJavadoc("\n@param domain domain object\n")
                .addJavadoc("@return JPA entity\n");

        // Ignore JPA technical fields when mapping from domain to entity
        addIgnoredMappings(toEntityBuilder, plan);
        mapperBuilder.addMethod(toEntityBuilder.build());

        // toDomain method
        mapperBuilder.addMethod(MethodSpec.methodBuilder("toDomain")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(domainType)
                .addParameter(entityType, "entity")
                .addJavadoc("Converts JPA entity to domain object.\n")
                .addJavadoc("\n@param entity JPA entity\n")
                .addJavadoc("@return domain object\n")
                .build());

        // Add @AfterMapping for bidirectional relationships
        addAfterMappingForRelationships(mapperBuilder, plan, entityType, domainType);

        JavaFile javaFile = JavaFile.builder(packageName, mapperBuilder.build()).build();

        return SourceFile.builder()
                .qualifiedTypeName(qualifiedName)
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }

    /**
     * Adds @Mapping annotations to ignore JPA technical fields.
     *
     * <p>JPA technical fields (version, audit, soft delete) don't exist in the domain model
     * and should be ignored during mapping.</p>
     */
    private void addIgnoredMappings(MethodSpec.Builder methodBuilder, JpaGenerationPlan plan) {
        ClassName mappingClass = ClassName.get("org.mapstruct", "Mapping");

        // Ignore version field (optimistic locking)
        if (plan.entityModel().enableOptimisticLocking()) {
            methodBuilder.addAnnotation(AnnotationSpec.builder(mappingClass)
                    .addMember("target", "$S", "version")
                    .addMember("ignore", "$L", true)
                    .build());
        }

        // Ignore audit fields
        if (plan.entityModel().enableAuditing()) {
            methodBuilder.addAnnotation(AnnotationSpec.builder(mappingClass)
                    .addMember("target", "$S", "createdAt")
                    .addMember("ignore", "$L", true)
                    .build());
            methodBuilder.addAnnotation(AnnotationSpec.builder(mappingClass)
                    .addMember("target", "$S", "updatedAt")
                    .addMember("ignore", "$L", true)
                    .build());
        }

        // Ignore soft delete field
        if (plan.entityModel().enableSoftDelete()) {
            methodBuilder.addAnnotation(AnnotationSpec.builder(mappingClass)
                    .addMember("target", "$S", "deletedAt")
                    .addMember("ignore", "$L", true)
                    .build());
        }
    }

    /**
     * Adds Value Object converter methods.
     *
     * <p>For each Value Object property (e.g., CustomerId), generates:</p>
     * <ul>
     *   <li>CustomerId → String (for persistence)</li>
     *   <li>String → CustomerId (for domain reconstruction)</li>
     * </ul>
     */
    private void addValueObjectConverters(TypeSpec.Builder mapperBuilder, JpaGenerationPlan plan) {
        String domainTypeName = plan.entityModel().domainType().render();
        Optional<DomainTypeView> domainTypeOpt = context.model().domain().findType(domainTypeName);

        if (domainTypeOpt.isEmpty()) {
            return;
        }

        DomainTypeView domainType = domainTypeOpt.get();

        // Track processed VO types to avoid duplicates
        java.util.Set<String> processedVoTypes = new java.util.HashSet<>();

        // Scan properties for Value Objects
        for (DomainPropertyView property : domainType.properties()) {
            String propertyTypeName = property.type().render();
            Optional<DomainTypeView> propertyDomainType =
                    context.model().domain().findType(propertyTypeName);

            if (propertyDomainType.isPresent()) {
                DomainTypeView voType = propertyDomainType.get();

                // Single-field Value Object: generate converters if not already processed
                if ((voType.kind() == DomainTypeKind.IDENTIFIER || voType.kind() == DomainTypeKind.RECORD)
                        && voType.properties().size() == 1
                        && !processedVoTypes.contains(voType.qualifiedName())) {

                    addValueObjectConverter(mapperBuilder, voType, voType.properties());
                    processedVoTypes.add(voType.qualifiedName());
                }
            }
        }

        // Also handle ID type if it's a Value Object and not already processed
        String idTypeName = plan.entityModel().idModel().originalType().render();
        Optional<DomainTypeView> idTypeOpt = context.model().domain().findType(idTypeName);

        if (idTypeOpt.isPresent()) {
            DomainTypeView idType = idTypeOpt.get();
            if ((idType.kind() == DomainTypeKind.IDENTIFIER || idType.kind() == DomainTypeKind.RECORD)
                    && idType.properties().size() == 1
                    && !processedVoTypes.contains(idType.qualifiedName())) {

                addValueObjectConverter(mapperBuilder, idType, idType.properties());
                processedVoTypes.add(idType.qualifiedName());
            }
        }
    }

    /**
     * Adds a bi-directional Value Object converter.
     *
     * <p>Uses unique method names to avoid conflicts when multiple VOs wrap the same type.
     * For example: mapCustomerIdToString, mapEmailToString both return String but have different names.</p>
     */
    private void addValueObjectConverter(
            TypeSpec.Builder mapperBuilder, DomainTypeView voType, List<DomainPropertyView> properties) {

        DomainPropertyView innerProperty = properties.get(0);
        TypeName innerType = TypeUtils.toTypeName(innerProperty.type());
        TypeName voTypeName = ClassName.bestGuess(voType.qualifiedName());

        // Generate unique method names based on VO type name
        String voSimpleName = voType.simpleName();
        String innerTypeName = innerProperty.type().render();
        String innerSimpleName = innerTypeName.substring(innerTypeName.lastIndexOf('.') + 1);

        // VO → Inner (e.g., CustomerId → String)
        String voToInnerMethodName = "map" + voSimpleName + "To" + innerSimpleName;
        mapperBuilder.addMethod(MethodSpec.methodBuilder(voToInnerMethodName)
                .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
                .returns(innerType)
                .addParameter(voTypeName, "valueObject")
                .addStatement("return valueObject == null ? null : valueObject.$L()", innerProperty.name())
                .addJavadoc("Converts $L to $L.\n", voTypeName, innerType)
                .build());

        // Inner → VO (e.g., String → CustomerId)
        String innerToVoMethodName = "map" + innerSimpleName + "To" + voSimpleName;
        mapperBuilder.addMethod(MethodSpec.methodBuilder(innerToVoMethodName)
                .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
                .returns(voTypeName)
                .addParameter(innerType, "value")
                .addStatement("return value == null ? null : new $T(value)", voTypeName)
                .addJavadoc("Converts $L to $L.\n", innerType, voTypeName)
                .build());
    }

    private String extractPackage(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? "" : qualifiedName.substring(0, lastDot);
    }

    /**
     * Adds @AfterMapping methods for bidirectional relationships.
     *
     * <p>For @OneToMany relationships with orphanRemoval=true (intra-aggregate compositions),
     * generates an @AfterMapping method that sets the parent reference on child entities.</p>
     *
     * <h2>Generated Example</h2>
     * <pre>{@code
     * @AfterMapping
     * default void setOrderItemBackReferences(@MappingTarget OrderEntity entity, Order domain) {
     *     if (entity.getOrderItems() != null) {
     *         entity.getOrderItems().forEach(item -> item.setOrder(entity));
     *     }
     * }
     * }</pre>
     */
    private void addAfterMappingForRelationships(
            TypeSpec.Builder mapperBuilder, JpaGenerationPlan plan, TypeName entityType, TypeName domainType) {

        if (!plan.entityModel().hasRelationships()) {
            return;
        }

        // Filter relationships that need back-reference management
        var relationshipsNeedingBackRefs = plan.entityModel().relationships().stream()
                .filter(rel -> rel.relationshipType()
                                == io.hexaglue.plugin.jpa.model.RelationshipModel.RelationshipType.ONE_TO_MANY
                        && rel.orphanRemoval()
                        && rel.isIntraAggregate())
                .toList();

        if (relationshipsNeedingBackRefs.isEmpty()) {
            return;
        }

        // Generate @AfterMapping method
        ClassName afterMappingClass = ClassName.get("org.mapstruct", "AfterMapping");
        ClassName mappingTargetClass = ClassName.get("org.mapstruct", "MappingTarget");

        MethodSpec.Builder afterMappingBuilder = MethodSpec.methodBuilder("setBackReferences")
                .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
                .addAnnotation(afterMappingClass)
                .returns(TypeName.VOID)
                .addParameter(com.palantir.javapoet.ParameterSpec.builder(entityType, "entity")
                        .addAnnotation(mappingTargetClass)
                        .build())
                .addParameter(domainType, "domain")
                .addJavadoc("Sets back-references for bidirectional relationships after entity mapping.\n")
                .addJavadoc("\n<p>This ensures that child entities have a reference to their parent.</p>\n")
                .addJavadoc("\n@param entity target entity (after mapping)\n")
                .addJavadoc("@param domain source domain object\n");

        // For each @OneToMany relationship, set the back-reference
        for (var relationship : relationshipsNeedingBackRefs) {
            String propertyName = relationship.propertyName();
            String getterName = "get" + capitalize(propertyName);

            // Derive the inverse property name from entity simple name
            // E.g., "OrderEntity" → "order"
            String entitySimpleName = plan.entityModel().entityClassName();
            String inversePropertyName = decapitalize(entitySimpleName.replace("Entity", ""));
            String inverseSetterName = "set" + capitalize(inversePropertyName);

            // Generate: if (entity.getOrderItems() != null) { entity.getOrderItems().forEach(item ->
            // item.setOrder(entity)); }
            afterMappingBuilder
                    .beginControlFlow("if (entity.$L() != null)", getterName)
                    .addStatement("entity.$L().forEach(item -> item.$L(entity))", getterName, inverseSetterName)
                    .endControlFlow();
        }

        mapperBuilder.addMethod(afterMappingBuilder.build());
    }

    /**
     * Capitalizes the first letter of a string.
     *
     * @param str string to capitalize
     * @return capitalized string
     */
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }

    /**
     * Decapitalizes the first letter of a string.
     *
     * @param str string to decapitalize
     * @return decapitalized string
     */
    private String decapitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toLowerCase() + str.substring(1);
    }

    private String extractSimpleName(String qualifiedName) {
        int lastDot = qualifiedName.lastIndexOf('.');
        return lastDot < 0 ? qualifiedName : qualifiedName.substring(lastDot + 1);
    }
}

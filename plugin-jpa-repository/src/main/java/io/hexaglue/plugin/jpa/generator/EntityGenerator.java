/**
 * This Source Code Form is part of the HexaGlue project.
 * Copyright (c) 2025 Scalastic
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * Commercial licensing options are available for organizations wishing
 * to use HexaGlue under terms different from the MPL 2.0.
 * Contact: info@hexaglue.io
 */
package io.hexaglue.plugin.jpa.generator;

import com.palantir.javapoet.AnnotationSpec;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.FieldSpec;
import com.palantir.javapoet.JavaFile;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.TypeName;
import com.palantir.javapoet.TypeSpec;
import io.hexaglue.plugin.jpa.config.JpaPluginOptions;
import io.hexaglue.plugin.jpa.model.EntityModel;
import io.hexaglue.plugin.jpa.model.IdModel;
import io.hexaglue.plugin.jpa.model.PropertyModel;
import io.hexaglue.plugin.jpa.model.RelationshipModel;
import io.hexaglue.plugin.jpa.util.TypeUtils;
import io.hexaglue.spi.codegen.SourceFile;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.lang.model.element.Modifier;

/**
 * Generates JPA entity classes with complete metadata.
 *
 * <p>This generator produces fully-annotated JPA @Entity classes with:</p>
 * <ul>
 *   <li><strong>@Entity and @Table</strong>: Entity and table metadata</li>
 *   <li><strong>@Id field</strong>: Primary key with generation strategy</li>
 *   <li><strong>Feature fields</strong>: Version, audit, soft delete</li>
 *   <li><strong>Domain properties</strong>: All persistent fields with @Column</li>
 *   <li><strong>Relationships</strong>: @OneToMany, @ManyToOne, @Embedded, @ElementCollection</li>
 *   <li><strong>Accessors</strong>: Getters and setters</li>
 *   <li><strong>No-arg constructor</strong>: Required by JPA</li>
 * </ul>
 *
 * <h2>Generated Code Example</h2>
 * <pre>{@code
 * @Entity
 * @Table(name = "customers", schema = "public")
 * public class CustomerEntity {
 *
 *     @Id
 *     @GeneratedValue(strategy = GenerationType.IDENTITY)
 *     private Long id;
 *
 *     @Version
 *     private Long version;
 *
 *     @Column(name = "created_at")
 *     private Instant createdAt;
 *
 *     @Column(name = "name", length = 100, nullable = false)
 *     private String name;
 *
 *     @Column(name = "email", length = 320, nullable = false, unique = true)
 *     private String email;
 *
 *     @Enumerated(EnumType.STRING)
 *     @Column(name = "status", nullable = false)
 *     private CustomerStatus status;
 *
 *     public CustomerEntity() {}
 *
 *     // Getters and setters...
 * }
 * }</pre>
 *
 * @since 0.4.0
 */
public final class EntityGenerator {

    private final JpaPluginOptions.IdGenerationStrategy idStrategy;

    public EntityGenerator(JpaPluginOptions options) {
        Objects.requireNonNull(options, "options");
        this.idStrategy = options.idStrategy();
    }

    /**
     * Generates a JPA entity source file from an entity model.
     *
     * @param entityModel entity metadata model
     * @param mergeMode merge mode for file generation
     * @return source file containing the generated entity
     */
    public SourceFile generate(EntityModel entityModel, io.hexaglue.spi.codegen.MergeMode mergeMode) {
        Objects.requireNonNull(entityModel, "entityModel");
        Objects.requireNonNull(mergeMode, "mergeMode");

        // Build entity class
        TypeSpec.Builder entityBuilder = TypeSpec.classBuilder(entityModel.entityClassName())
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("JPA entity for $L.\n", entityModel.domainType().render())
                .addJavadoc("\n<p>Generated by HexaGlue JPA plugin.</p>\n");

        // Add @Entity annotation
        entityBuilder.addAnnotation(ClassName.get("jakarta.persistence", "Entity"));

        // Add @Table annotation
        addTableAnnotation(entityBuilder, entityModel);

        // Add @Where annotation for soft delete filtering
        if (entityModel.enableSoftDelete()) {
            entityBuilder.addAnnotation(AnnotationSpec.builder(ClassName.get("org.hibernate.annotations", "Where"))
                    .addMember("clause", "$S", "deleted_at IS NULL")
                    .build());
        }

        // Add @Id field
        addIdField(entityBuilder, entityModel.idModel());

        // Add feature fields (version, audit, soft delete)
        if (entityModel.enableOptimisticLocking()) {
            addVersionField(entityBuilder);
        }
        if (entityModel.enableAuditing()) {
            addAuditFields(entityBuilder);
        }
        if (entityModel.enableSoftDelete()) {
            addSoftDeleteField(entityBuilder);
        }

        // Collect property names that are handled as relationships to avoid duplication
        List<String> relationshipPropertyNames = entityModel.relationships().stream()
                .map(RelationshipModel::propertyName)
                .toList();

        // Add domain properties (skip those already handled as relationships)
        for (PropertyModel property : entityModel.properties()) {
            if (!relationshipPropertyNames.contains(property.name())) {
                addPropertyField(entityBuilder, property, entityModel);
            }
        }

        // Add relationship fields
        for (RelationshipModel relationship : entityModel.relationships()) {
            addRelationshipField(entityBuilder, relationship, entityModel);
        }

        // Add no-arg constructor (required by JPA)
        entityBuilder.addMethod(MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("No-arg constructor required by JPA.\n")
                .build());

        // Add getters and setters
        addIdAccessors(entityBuilder, entityModel.idModel());

        // Add accessors for technical fields
        if (entityModel.enableOptimisticLocking()) {
            addVersionAccessors(entityBuilder);
        }
        if (entityModel.enableAuditing()) {
            addAuditAccessors(entityBuilder);
        }
        if (entityModel.enableSoftDelete()) {
            addSoftDeleteAccessors(entityBuilder);
        }

        // Add accessors for domain properties (skip those already handled as relationships)
        for (PropertyModel property : entityModel.properties()) {
            if (!relationshipPropertyNames.contains(property.name())) {
                addPropertyAccessors(entityBuilder, property, entityModel);
            }
        }

        // Add accessors for relationships
        for (RelationshipModel relationship : entityModel.relationships()) {
            addRelationshipAccessors(entityBuilder, relationship, entityModel);
        }

        // Build Java file
        JavaFile javaFile = JavaFile.builder(entityModel.entityPackage(), entityBuilder.build())
                .build();

        return SourceFile.builder()
                .qualifiedTypeName(entityModel.qualifiedClassName())
                .content(javaFile.toString())
                .mergeMode(mergeMode)
                .build();
    }

    /**
     * Adds @Table annotation with table name and optional schema.
     */
    private void addTableAnnotation(TypeSpec.Builder entityBuilder, EntityModel entityModel) {
        AnnotationSpec.Builder tableBuilder = AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Table"))
                .addMember("name", "$S", entityModel.tableName());

        entityModel.schemaIfPresent().ifPresent(schema -> tableBuilder.addMember("schema", "$S", schema));

        entityBuilder.addAnnotation(tableBuilder.build());
    }

    /**
     * Adds @Id field with generation strategy.
     */
    private void addIdField(TypeSpec.Builder entityBuilder, IdModel idModel) {
        // Composite IDs use @EmbeddedId
        if (idModel.isComposite()) {
            addEmbeddedIdField(entityBuilder, idModel);
            return;
        }

        // Simple IDs use @Id
        TypeName idType = TypeUtils.toTypeName(idModel.unwrappedType());

        FieldSpec.Builder idFieldBuilder = FieldSpec.builder(idType, "id", Modifier.PRIVATE)
                .addAnnotation(ClassName.get("jakarta.persistence", "Id"));

        // Add @GeneratedValue if needed
        if (idModel.requiresGeneratedValue()) {
            AnnotationSpec generatedValue = buildGeneratedValueAnnotation(idModel);
            idFieldBuilder.addAnnotation(generatedValue);
        }

        entityBuilder.addField(idFieldBuilder.build());
    }

    /**
     * Adds @EmbeddedId field for composite IDs.
     *
     * <p>Composite IDs use a separate @Embeddable class for the ID.</p>
     */
    private void addEmbeddedIdField(TypeSpec.Builder entityBuilder, IdModel idModel) {
        // Derive embeddable type name from original type
        String originalTypeName = idModel.originalType().render();
        String embeddableSimpleName = originalTypeName.substring(originalTypeName.lastIndexOf('.') + 1) + "Embeddable";

        // Assume embeddable is in same base package + ".embeddable"
        // This matches the convention used in EmbeddableGenerator
        String embeddablePackage = extractPackagePrefix(originalTypeName) + ".embeddable";
        TypeName embeddableType = ClassName.get(embeddablePackage, embeddableSimpleName);

        FieldSpec.Builder idFieldBuilder = FieldSpec.builder(embeddableType, "id", Modifier.PRIVATE)
                .addAnnotation(ClassName.get("jakarta.persistence", "EmbeddedId"))
                .addJavadoc("Composite primary key.\n");

        entityBuilder.addField(idFieldBuilder.build());
    }

    /**
     * Extracts base package prefix before domain package segment.
     *
     * <p>Example: "com.example.domain.order.OrderId" → "com.example"</p>
     */
    private String extractPackagePrefix(String qualifiedTypeName) {
        int lastDot = qualifiedTypeName.lastIndexOf('.');
        if (lastDot < 0) {
            return "";
        }
        String packageName = qualifiedTypeName.substring(0, lastDot);

        // Remove domain-specific segments (domain, model, etc.)
        packageName = packageName.replaceAll("\\.domain(\\.[^.]+)?$", "");
        packageName = packageName.replaceAll("\\.model(\\.[^.]+)?$", "");

        return packageName;
    }

    /**
     * Builds @GeneratedValue annotation based on strategy.
     */
    private AnnotationSpec buildGeneratedValueAnnotation(IdModel idModel) {
        ClassName generatedValueClass = ClassName.get("jakarta.persistence", "GeneratedValue");
        ClassName generationTypeClass = ClassName.get("jakarta.persistence", "GenerationType");

        AnnotationSpec.Builder builder = AnnotationSpec.builder(generatedValueClass);

        switch (idStrategy) {
            case IDENTITY:
                builder.addMember("strategy", "$T.IDENTITY", generationTypeClass);
                break;
            case SEQUENCE:
                builder.addMember("strategy", "$T.SEQUENCE", generationTypeClass);
                idModel.sequenceNameIfPresent().ifPresent(seqName -> builder.addMember("generator", "$S", "seq"));
                break;
            case AUTO:
                builder.addMember("strategy", "$T.AUTO", generationTypeClass);
                break;
            default:
                // UUID and ASSIGNED don't use @GeneratedValue
                break;
        }

        return builder.build();
    }

    /**
     * Adds @Version field for optimistic locking.
     */
    private void addVersionField(TypeSpec.Builder entityBuilder) {
        entityBuilder.addField(FieldSpec.builder(long.class, "version", Modifier.PRIVATE)
                .addAnnotation(ClassName.get("jakarta.persistence", "Version"))
                .addJavadoc("Version field for optimistic locking.\n")
                .build());
    }

    /**
     * Adds audit fields (createdAt, updatedAt).
     */
    private void addAuditFields(TypeSpec.Builder entityBuilder) {
        ClassName instantClass = ClassName.get("java.time", "Instant");

        entityBuilder.addField(FieldSpec.builder(instantClass, "createdAt", Modifier.PRIVATE)
                .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                        .addMember("name", "$S", "created_at")
                        .build())
                .addJavadoc("Creation timestamp.\n")
                .build());

        entityBuilder.addField(FieldSpec.builder(instantClass, "updatedAt", Modifier.PRIVATE)
                .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                        .addMember("name", "$S", "updated_at")
                        .build())
                .addJavadoc("Last update timestamp.\n")
                .build());
    }

    /**
     * Adds deletedAt field for soft delete.
     */
    private void addSoftDeleteField(TypeSpec.Builder entityBuilder) {
        ClassName instantClass = ClassName.get("java.time", "Instant");

        entityBuilder.addField(FieldSpec.builder(instantClass, "deletedAt", Modifier.PRIVATE)
                .addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                        .addMember("name", "$S", "deleted_at")
                        .build())
                .addJavadoc("Soft delete timestamp.\n")
                .build());
    }

    /**
     * Adds a domain property field with @Column or @Embedded annotation.
     */
    private void addPropertyField(TypeSpec.Builder entityBuilder, PropertyModel property, EntityModel entityModel) {
        // For embedded Value Objects, use different type (Embeddable)
        TypeName propertyType;
        if (property.embedded()) {
            // Use the embeddable type instead of the domain type
            String voTypeName = property.type().render();
            String embeddableTypeName = voTypeName.substring(voTypeName.lastIndexOf('.') + 1) + "Embeddable";
            String embeddablePackage = entityModel.entityPackage().replace(".entity", ".embeddable");
            propertyType = ClassName.get(embeddablePackage, embeddableTypeName);
        } else {
            propertyType = TypeUtils.toTypeName(property.type());
        }

        FieldSpec.Builder fieldBuilder = FieldSpec.builder(propertyType, property.name(), Modifier.PRIVATE);

        // Embedded Value Objects use @Embedded
        if (property.embedded()) {
            fieldBuilder.addAnnotation(ClassName.get("jakarta.persistence", "Embedded"));
            entityBuilder.addField(fieldBuilder.build());
            return;
        }

        // Add special annotations first
        if (property.enumerated()) {
            fieldBuilder.addAnnotation(AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Enumerated"))
                    .addMember("value", "$T.STRING", ClassName.get("jakarta.persistence", "EnumType"))
                    .build());
        }

        if (property.lob()) {
            fieldBuilder.addAnnotation(ClassName.get("jakarta.persistence", "Lob"));
        }

        // Add @Column annotation
        AnnotationSpec.Builder columnBuilder = AnnotationSpec.builder(ClassName.get("jakarta.persistence", "Column"))
                .addMember("name", "$S", property.columnName())
                .addMember("nullable", "$L", property.nullable());

        property.lengthIfPresent().ifPresent(length -> columnBuilder.addMember("length", "$L", length));

        if (property.unique()) {
            columnBuilder.addMember("unique", "$L", true);
        }

        fieldBuilder.addAnnotation(columnBuilder.build());

        entityBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds getter and setter for ID field.
     */
    private void addIdAccessors(TypeSpec.Builder entityBuilder, IdModel idModel) {
        TypeName idType;

        // For composite IDs, use the embeddable type
        if (idModel.isComposite()) {
            String originalTypeName = idModel.originalType().render();
            String embeddableSimpleName =
                    originalTypeName.substring(originalTypeName.lastIndexOf('.') + 1) + "Embeddable";
            String embeddablePackage = extractPackagePrefix(originalTypeName) + ".embeddable";
            idType = ClassName.get(embeddablePackage, embeddableSimpleName);
        } else {
            idType = TypeUtils.toTypeName(idModel.unwrappedType());
        }

        // Getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("getId")
                .addModifiers(Modifier.PUBLIC)
                .returns(idType)
                .addStatement("return id")
                .build());

        // Setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("setId")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(idType, "id")
                .addStatement("this.id = id")
                .build());
    }

    /**
     * Adds getter and setter for a property.
     * Note: For embedded VOs, accessors use the embeddable type (entity field type).
     */
    private void addPropertyAccessors(TypeSpec.Builder entityBuilder, PropertyModel property, EntityModel entityModel) {
        // For embedded VOs, use embeddable type for accessors
        TypeName accessorType;
        if (property.embedded()) {
            String voTypeName = property.type().render();
            String embeddableTypeName = voTypeName.substring(voTypeName.lastIndexOf('.') + 1) + "Embeddable";
            String embeddablePackage = entityModel.entityPackage().replace(".entity", ".embeddable");
            accessorType = ClassName.get(embeddablePackage, embeddableTypeName);
        } else {
            accessorType = TypeUtils.toTypeName(property.type());
        }

        String capitalizedName = capitalize(property.name());

        // Getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("get" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .returns(accessorType)
                .addStatement("return $L", property.name())
                .build());

        // Setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("set" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(accessorType, property.name())
                .addStatement("this.$L = $L", property.name(), property.name())
                .build());
    }

    /**
     * Adds getter and setter for version field (optimistic locking).
     */
    private void addVersionAccessors(TypeSpec.Builder entityBuilder) {
        // Getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("getVersion")
                .addModifiers(Modifier.PUBLIC)
                .returns(long.class)
                .addStatement("return version")
                .build());

        // Setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("setVersion")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(long.class, "version")
                .addStatement("this.version = version")
                .build());
    }

    /**
     * Adds getters and setters for audit fields (createdAt, updatedAt).
     */
    private void addAuditAccessors(TypeSpec.Builder entityBuilder) {
        ClassName instantClass = ClassName.get("java.time", "Instant");

        // createdAt getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("getCreatedAt")
                .addModifiers(Modifier.PUBLIC)
                .returns(instantClass)
                .addStatement("return createdAt")
                .build());

        // createdAt setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("setCreatedAt")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(instantClass, "createdAt")
                .addStatement("this.createdAt = createdAt")
                .build());

        // updatedAt getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("getUpdatedAt")
                .addModifiers(Modifier.PUBLIC)
                .returns(instantClass)
                .addStatement("return updatedAt")
                .build());

        // updatedAt setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("setUpdatedAt")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(instantClass, "updatedAt")
                .addStatement("this.updatedAt = updatedAt")
                .build());
    }

    /**
     * Adds getter and setter for deletedAt field (soft delete).
     */
    private void addSoftDeleteAccessors(TypeSpec.Builder entityBuilder) {
        ClassName instantClass = ClassName.get("java.time", "Instant");

        // Getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("getDeletedAt")
                .addModifiers(Modifier.PUBLIC)
                .returns(instantClass)
                .addStatement("return deletedAt")
                .build());

        // Setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("setDeletedAt")
                .addModifiers(Modifier.PUBLIC)
                .addParameter(instantClass, "deletedAt")
                .addStatement("this.deletedAt = deletedAt")
                .build());
    }

    /**
     * Adds a relationship field with appropriate JPA annotation.
     *
     * <p>Delegates to specific methods based on relationship type:</p>
     * <ul>
     *   <li>{@code ONE_TO_MANY} → {@link #addOneToManyField}</li>
     *   <li>{@code MANY_TO_ONE} → {@link #addManyToOneField}</li>
     *   <li>{@code EMBEDDED} → {@link #addEmbeddedField}</li>
     *   <li>{@code ELEMENT_COLLECTION} → {@link #addElementCollectionField}</li>
     * </ul>
     */
    private void addRelationshipField(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {
        switch (relationship.relationshipType()) {
            case ONE_TO_MANY -> addOneToManyField(entityBuilder, relationship, entityModel);
            case MANY_TO_ONE -> addManyToOneField(entityBuilder, relationship, entityModel);
            case EMBEDDED -> addEmbeddedField(entityBuilder, relationship, entityModel);
            case ELEMENT_COLLECTION -> addElementCollectionField(entityBuilder, relationship, entityModel);
            case EMBEDDED_ID -> {
                // Not implemented yet - will be added in Phase 5.3
            }
        }
    }

    /**
     * Adds a @OneToMany relationship field.
     *
     * <p>Generated code example:</p>
     * <pre>{@code
     * @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
     * private List<OrderItemEntity> items = new ArrayList<>();
     * }</pre>
     */
    private void addOneToManyField(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {

        // Determine collection type and element type
        TypeName elementType = relationship
                .targetEntityNameIfPresent()
                .<TypeName>map(name -> ClassName.get(entityModel.entityPackage(), name))
                .orElseGet(() -> TypeUtils.toTypeName(relationship.targetType()));

        TypeName collectionType = buildCollectionTypeName(relationship, elementType);

        FieldSpec.Builder fieldBuilder =
                FieldSpec.builder(collectionType, relationship.propertyName(), Modifier.PRIVATE);

        // Add @OneToMany annotation
        AnnotationSpec.Builder oneToManyBuilder =
                AnnotationSpec.builder(ClassName.get("jakarta.persistence", "OneToMany"));

        // Add cascade
        if (relationship.cascade().length > 0) {
            ClassName cascadeTypeClass = ClassName.get("jakarta.persistence", "CascadeType");
            String cascadeValues = buildCascadeValues(relationship.cascade(), cascadeTypeClass);
            oneToManyBuilder.addMember("cascade", cascadeValues);
        }

        // Add fetch
        ClassName fetchTypeClass = ClassName.get("jakarta.persistence", "FetchType");
        oneToManyBuilder.addMember("fetch", "$T." + relationship.fetch().name(), fetchTypeClass);

        // Add orphanRemoval if applicable
        if (relationship.orphanRemoval()) {
            oneToManyBuilder.addMember("orphanRemoval", "$L", true);
        }

        // Add mappedBy if bidirectional
        relationship.mappedByIfPresent().ifPresent(mappedBy -> oneToManyBuilder.addMember("mappedBy", "$S", mappedBy));

        fieldBuilder.addAnnotation(oneToManyBuilder.build());

        // Initialize collection to avoid null
        fieldBuilder.initializer("new $T<>()", ArrayList.class);

        entityBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds a @ManyToOne relationship field.
     *
     * <p>Generated code example:</p>
     * <pre>{@code
     * @ManyToOne(fetch = FetchType.LAZY)
     * @JoinColumn(name = "parent_id")
     * private ParentEntity parent;
     * }</pre>
     */
    private void addManyToOneField(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {

        TypeName targetType = relationship
                .targetEntityNameIfPresent()
                .<TypeName>map(name -> ClassName.get(entityModel.entityPackage(), name))
                .orElseGet(() -> TypeUtils.toTypeName(relationship.targetType()));

        FieldSpec.Builder fieldBuilder = FieldSpec.builder(targetType, relationship.propertyName(), Modifier.PRIVATE);

        // Add @ManyToOne annotation
        AnnotationSpec.Builder manyToOneBuilder =
                AnnotationSpec.builder(ClassName.get("jakarta.persistence", "ManyToOne"));

        // Add fetch
        ClassName fetchTypeClass = ClassName.get("jakarta.persistence", "FetchType");
        manyToOneBuilder.addMember("fetch", "$T." + relationship.fetch().name(), fetchTypeClass);

        fieldBuilder.addAnnotation(manyToOneBuilder.build());

        // Add @JoinColumn if specified
        relationship.joinColumnIfPresent().ifPresent(joinColumn -> {
            AnnotationSpec joinColumnAnnotation = AnnotationSpec.builder(
                            ClassName.get("jakarta.persistence", "JoinColumn"))
                    .addMember("name", "$S", joinColumn)
                    .build();
            fieldBuilder.addAnnotation(joinColumnAnnotation);
        });

        entityBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds an @Embedded relationship field.
     *
     * <p>Generated code example:</p>
     * <pre>{@code
     * @Embedded
     * private AddressEmbeddable address;
     * }</pre>
     */
    private void addEmbeddedField(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {

        // Build embeddable type name
        String voTypeName = relationship.targetType().render();
        String embeddableTypeName = voTypeName.substring(voTypeName.lastIndexOf('.') + 1) + "Embeddable";
        String embeddablePackage = entityModel.entityPackage().replace(".entity", ".embeddable");
        TypeName embeddableType = ClassName.get(embeddablePackage, embeddableTypeName);

        FieldSpec.Builder fieldBuilder =
                FieldSpec.builder(embeddableType, relationship.propertyName(), Modifier.PRIVATE);

        // Add @Embedded annotation
        fieldBuilder.addAnnotation(ClassName.get("jakarta.persistence", "Embedded"));

        entityBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds an @ElementCollection field.
     *
     * <p>Generated code example:</p>
     * <pre>{@code
     * @ElementCollection(fetch = FetchType.LAZY)
     * private List<String> tags = new ArrayList<>();
     * }</pre>
     */
    private void addElementCollectionField(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {

        TypeName elementType = TypeUtils.toTypeName(relationship.targetType());
        TypeName collectionType = buildCollectionTypeName(relationship, elementType);

        FieldSpec.Builder fieldBuilder =
                FieldSpec.builder(collectionType, relationship.propertyName(), Modifier.PRIVATE);

        // Add @ElementCollection annotation
        AnnotationSpec.Builder elementCollectionBuilder =
                AnnotationSpec.builder(ClassName.get("jakarta.persistence", "ElementCollection"));

        // Add fetch
        ClassName fetchTypeClass = ClassName.get("jakarta.persistence", "FetchType");
        elementCollectionBuilder.addMember("fetch", "$T." + relationship.fetch().name(), fetchTypeClass);

        fieldBuilder.addAnnotation(elementCollectionBuilder.build());

        // Initialize collection to avoid null
        fieldBuilder.initializer("new $T<>()", ArrayList.class);

        entityBuilder.addField(fieldBuilder.build());
    }

    /**
     * Adds getter and setter for a relationship field.
     */
    private void addRelationshipAccessors(
            TypeSpec.Builder entityBuilder, RelationshipModel relationship, EntityModel entityModel) {

        // Determine accessor type based on relationship type
        TypeName accessorType = buildRelationshipAccessorType(relationship, entityModel);
        String capitalizedName = capitalize(relationship.propertyName());

        // Getter
        entityBuilder.addMethod(MethodSpec.methodBuilder("get" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .returns(accessorType)
                .addStatement("return $L", relationship.propertyName())
                .build());

        // Setter
        entityBuilder.addMethod(MethodSpec.methodBuilder("set" + capitalizedName)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(accessorType, relationship.propertyName())
                .addStatement("this.$L = $L", relationship.propertyName(), relationship.propertyName())
                .build());
    }

    /**
     * Builds the accessor type for a relationship.
     */
    private TypeName buildRelationshipAccessorType(RelationshipModel relationship, EntityModel entityModel) {
        return switch (relationship.relationshipType()) {
            case ONE_TO_MANY, ELEMENT_COLLECTION -> {
                TypeName elementType = relationship
                        .targetEntityNameIfPresent()
                        .<TypeName>map(name -> ClassName.get(entityModel.entityPackage(), name))
                        .orElseGet(() -> TypeUtils.toTypeName(relationship.targetType()));
                yield buildCollectionTypeName(relationship, elementType);
            }
            case MANY_TO_ONE ->
                relationship
                        .targetEntityNameIfPresent()
                        .<TypeName>map(name -> ClassName.get(entityModel.entityPackage(), name))
                        .orElseGet(() -> TypeUtils.toTypeName(relationship.targetType()));
            case EMBEDDED -> {
                String voTypeName = relationship.targetType().render();
                String embeddableTypeName = voTypeName.substring(voTypeName.lastIndexOf('.') + 1) + "Embeddable";
                String embeddablePackage = entityModel.entityPackage().replace(".entity", ".embeddable");
                yield ClassName.get(embeddablePackage, embeddableTypeName);
            }
            case EMBEDDED_ID -> TypeUtils.toTypeName(relationship.targetType());
        };
    }

    /**
     * Builds a collection type name (List, Set, Map).
     */
    private TypeName buildCollectionTypeName(RelationshipModel relationship, TypeName elementType) {
        return switch (relationship.collectionType()) {
            case LIST -> com.palantir.javapoet.ParameterizedTypeName.get(ClassName.get(List.class), elementType);
            case SET ->
                com.palantir.javapoet.ParameterizedTypeName.get(ClassName.get(java.util.Set.class), elementType);
            case MAP -> {
                // For maps, we need key and value types - for now default to String key
                TypeName keyType = ClassName.get(String.class);
                yield com.palantir.javapoet.ParameterizedTypeName.get(
                        ClassName.get(java.util.Map.class), keyType, elementType);
            }
        };
    }

    /**
     * Builds cascade values string for annotation.
     */
    private String buildCascadeValues(RelationshipModel.CascadeType[] cascadeTypes, ClassName cascadeTypeClass) {
        if (cascadeTypes.length == 1) {
            return "$T." + cascadeTypes[0].name();
        }

        StringBuilder sb = new StringBuilder("{");
        for (int i = 0; i < cascadeTypes.length; i++) {
            if (i > 0) sb.append(", ");
            sb.append("$T.").append(cascadeTypes[i].name());
        }
        sb.append("}");
        return sb.toString();
    }

    /**
     * Capitalizes the first letter of a string.
     */
    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
}
